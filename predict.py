import _init_paths
import torch
import torch.nn as nn
import time
import glob
from model.basemodel import MyResNet, MyVgg16, IMCEC, ViTranformer
from utils.preprocessing import read_image
import argparse


def load_std(path, device):
    from collections import OrderedDict
    checkpoint = torch.load(path, map_location=device)
    new_state_dict = OrderedDict()
    for k, v in checkpoint['state_dict'].items():
        name = k.replace('model.', '')
        new_state_dict[name] = v
    return new_state_dict


def predict(args, device):
    # new_state_dict = load_std(args.weight_dir, device)

    model = IMCEC(num_classes=2)
    checkpoint = torch.load(args.weight_dir, map_location=device)
    model.load_state_dict(checkpoint['state_dict'])
    # model.to(device)
    model.eval()
    acc = 0
    label = 0
    for image_path in glob.glob(args.test_dir + "*"):
        image = read_image(image_path, device)
        image = image.unsqueeze(0)
        embed_feat = model(image)
        _, pred = torch.max(embed_feat.data, 1)
        if(pred==label):
            acc += 1

    print(f'Acc: {100*acc/len(glob.glob(args.test_dir + "*"))}%')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='PyTorch Siamese Example')
    parser.add_argument('--weight_dir', default='./resutls/exp_IMCEC_update/best.pt', type=str, help='Weight results model')
    parser.add_argument('--test_dir', default='G:/NCKH_DUT/Malware/dataset_old/RGB_test/RGB/benign/', type=str, help='Test image')
    parser.add_argument('--num_class', default=2, type=int, help='number of class')
    parser.add_argument('--cuda', action='store_true', default=False, help='enables CUDA training')

    global args, device
    args = parser.parse_args()
    args.cuda = args.cuda and torch.cuda.is_available()

    if args.cuda:
        device = torch.device('cuda')
    else:
        device = torch.device('cpu')

    predict(args, device)

