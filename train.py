import yaml
from munch import Munch

import _init_paths
import os
import argparse

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

from torch.autograd import Variable
import torch.backends.cudnn as cudnn
from dataloader.load_dataset import ImageLoaderModule
from model.net import get_model
from tqdm import tqdm
import warnings

from utils.plot import plot_acc, plot_loss, plot_metrics


warnings.filterwarnings("ignore")


def make_dir_if_not_exist(path):
    if not os.path.exists(path):
        os.makedirs(path)


class AverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self):
        self.reset()

    def reset(self):
        self.val = 0
        self.avg = 0
        self.sumval = 0
        self.count = 0

    def update(self, val, n=1):
        self.val = val
        self.sumval += val * n
        self.count += n
        self.avg = self.sumval / self.count


def main():
    torch.manual_seed(1)
    if args.cuda:
        torch.cuda.manual_seed(1)
    cudnn.benchmark = True

    exp_dir = os.path.join(args.result_dir, args.exp_name)
    make_dir_if_not_exist(exp_dir)


    data_loader = ImageLoaderModule(config=args)
    acc_tests, loss_tests, acc_trains, loss_trains, = [], [], [], []
    results = {}

    for id_k_fold in range(1, args.k_fold+1):

        print(f'Train with id k_fold: {id_k_fold}')

        # Build Model
        model = get_model(args, device)

        if model is None:
            print('No model!')
            return

        # Criterion and Optimizer
        params = []
        for key, value in dict(model.named_parameters()).items():
            if value.requires_grad:
                params += [{'params': [value]}]
        print(f'Total parameters => {sum([p.data.nelement() for p in model.parameters()])}')

        # imbalance datasets
        criterion = nn.CrossEntropyLoss().cuda() if args.cuda else nn.CrossEntropyLoss()
        optimizer = optim.Adam(model.parameters(), lr=args.lr)

        # Train Test Loop
        best_loss = 100


        test_data_loader = data_loader.test_iter(id_k_fold=id_k_fold)
        train_data_loader = data_loader.train_iter(id_k_fold=id_k_fold)


        exp_dir_fold = os.path.join(exp_dir, f"fold_{id_k_fold}")
        make_dir_if_not_exist(exp_dir_fold)

        for epoch in range(1, args.epochs + 1):
            # Init data loaders
            # Test train
            train(train_data_loader, model, criterion, optimizer, epoch, acc_trains, loss_trains)
            loss_test, acc_test, predicts, targets = test(test_data_loader, model, criterion, epoch, acc_tests, loss_tests)


            plot_acc(log_dir=exp_dir_fold, acc_train=acc_trains, acc_test=acc_tests)
            plot_loss(log_dir=exp_dir_fold, loss_train=loss_trains, loss_test=loss_tests)

            is_best = loss_test < best_loss
            if is_best:
                # Save model
                file_name = os.path.join(exp_dir_fold, f"best_{id_k_fold}.pt")
                save_checkpoint(model.state_dict(), file_name)
                plot_metrics(log_dir=exp_dir_fold,
                             predicts=predicts,
                             targets=targets,
                             classes=args.classes)
                results[id_k_fold] = acc_test
                best_loss = loss_test

    # Print fold results
    print(f'K-FOLD CROSS VALIDATION RESULTS FOR {args.k_fold} FOLDS')
    print('--------------------------------')
    sum_avg = 0.0
    for key, value in results.items():
        print(f'Fold {key}: {value} %')
        sum_avg += value
    print(f'Average Acc: {sum_avg/len(results.items())} %')


def train(data, model, criterion, optimizer, epoch, acc_trains, loss_trains):
    print("******** Training ********")
    losses = AverageMeter()
    accs = AverageMeter()
    model.train()
    for batch_idx, datasets in enumerate(tqdm(data)):
        images, labels = datasets

        images = Variable(images.to(device))
        labels = Variable(labels.to(device))

        embed_feat = model(images)
        loss = criterion(embed_feat, labels)

        _, preds = torch.max(embed_feat.data, 1)
        acc = torch.sum(preds == labels.data)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        losses.update(loss.item())
        accs.update(acc.item() / labels.shape[0])

    acc_trains.append(accs.avg)
    loss_trains.append(losses.avg)
    print('Train Epoch: {}\t'
          'Loss: {:.4f} \t'
          'Acc: {:.2f}% \t'.format(
        epoch, losses.avg, 100 * accs.avg))


def test(data, model, criterion, epoch, acc_tests, loss_tests):
    print("******** Testing ********")
    losses = AverageMeter()
    accs = AverageMeter()
    predicts, targets = [], []
    with torch.no_grad():
        model.eval()
        for batch_idx, datasets in enumerate(tqdm(data)):
            images, labels = datasets

            images = Variable(images.to(device))
            labels = Variable(labels.to(device))

            embed_feat = model(images)
            loss = criterion(embed_feat, labels)

            _, preds = torch.max(embed_feat.data, 1)
            acc = torch.sum(preds == labels.data)

            losses.update(loss.item())
            accs.update(acc.item() / labels.shape[0])
            predicts.extend(preds.tolist())
            targets.extend(labels.tolist())

        print('Test set: \tLoss: {:.4f}, \tAcc: {:.2f}%'.format(losses.avg, 100 * accs.avg))

        loss_tests.append(losses.avg)
        acc_tests.append(accs.avg)
        return losses.avg, accs.avg, predicts, targets


def save_checkpoint(state, file_name):
    torch.save(state, file_name)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='PyTorch Siamese Example')
    parser.add_argument('--config', default='config/myconfig.yaml', type=str, help='path to yaml config file')
    parser.add_argument('--cuda', action='store_true', default=True, help='enables CUDA training')
    global args, device, model

    args = parser.parse_args()
    args.cuda = args.cuda and torch.cuda.is_available()
    device = 'cuda' if args.cuda else 'cpu'
    with open(args.config) as f:
        params = yaml.full_load(f)
    args = Munch(params)

    main()
